/*
 * Kubernetes
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.21.1
 * 
 * Generated by: https://openapi-generator.tech
 */

use std::rc::Rc;
use std::borrow::Borrow;
#[allow(unused_imports)]
use std::option::Option;

use hyper;
use serde_json;
use futures::Future;

use super::{Error, configuration};
use super::request as __internal_request;

pub struct CoreV1ApiClient<C: hyper::client::Connect> {
    configuration: Rc<configuration::Configuration<C>>,
}

impl<C: hyper::client::Connect> CoreV1ApiClient<C> {
    pub fn new(configuration: Rc<configuration::Configuration<C>>) -> CoreV1ApiClient<C> {
        CoreV1ApiClient {
            configuration,
        }
    }
}

pub trait CoreV1Api {
    fn connect_delete_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_delete_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_delete_namespaced_service_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_delete_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_delete_node_proxy(&self, name: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_delete_node_proxy_with_path(&self, name: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_get_namespaced_pod_attach(&self, name: &str, namespace: &str, container: Option<&str>, stderr: Option<bool>, stdin: Option<bool>, stdout: Option<bool>, tty: Option<bool>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_get_namespaced_pod_exec(&self, name: &str, namespace: &str, command: Option<&str>, container: Option<&str>, stderr: Option<bool>, stdin: Option<bool>, stdout: Option<bool>, tty: Option<bool>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_get_namespaced_pod_portforward(&self, name: &str, namespace: &str, ports: Option<i32>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_get_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_get_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_get_namespaced_service_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_get_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_get_node_proxy(&self, name: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_get_node_proxy_with_path(&self, name: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_head_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_head_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_head_namespaced_service_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_head_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_head_node_proxy(&self, name: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_head_node_proxy_with_path(&self, name: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_options_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_options_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_options_namespaced_service_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_options_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_options_node_proxy(&self, name: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_options_node_proxy_with_path(&self, name: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_patch_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_patch_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_patch_namespaced_service_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_patch_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_patch_node_proxy(&self, name: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_patch_node_proxy_with_path(&self, name: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_post_namespaced_pod_attach(&self, name: &str, namespace: &str, container: Option<&str>, stderr: Option<bool>, stdin: Option<bool>, stdout: Option<bool>, tty: Option<bool>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_post_namespaced_pod_exec(&self, name: &str, namespace: &str, command: Option<&str>, container: Option<&str>, stderr: Option<bool>, stdin: Option<bool>, stdout: Option<bool>, tty: Option<bool>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_post_namespaced_pod_portforward(&self, name: &str, namespace: &str, ports: Option<i32>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_post_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_post_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_post_namespaced_service_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_post_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_post_node_proxy(&self, name: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_post_node_proxy_with_path(&self, name: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_put_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_put_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_put_namespaced_service_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_put_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_put_node_proxy(&self, name: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn connect_put_node_proxy_with_path(&self, name: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn create_namespace(&self, body: crate::models::V1Namespace, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Namespace, Error = Error<serde_json::Value>>>;
    fn create_namespaced_binding(&self, namespace: &str, body: crate::models::V1Binding, dry_run: Option<&str>, field_manager: Option<&str>, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Binding, Error = Error<serde_json::Value>>>;
    fn create_namespaced_config_map(&self, namespace: &str, body: crate::models::V1ConfigMap, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ConfigMap, Error = Error<serde_json::Value>>>;
    fn create_namespaced_endpoints(&self, namespace: &str, body: crate::models::V1Endpoints, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Endpoints, Error = Error<serde_json::Value>>>;
    fn create_namespaced_event(&self, namespace: &str, body: crate::models::CoreV1Event, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::CoreV1Event, Error = Error<serde_json::Value>>>;
    fn create_namespaced_limit_range(&self, namespace: &str, body: crate::models::V1LimitRange, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1LimitRange, Error = Error<serde_json::Value>>>;
    fn create_namespaced_persistent_volume_claim(&self, namespace: &str, body: crate::models::V1PersistentVolumeClaim, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PersistentVolumeClaim, Error = Error<serde_json::Value>>>;
    fn create_namespaced_pod(&self, namespace: &str, body: crate::models::V1Pod, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Pod, Error = Error<serde_json::Value>>>;
    fn create_namespaced_pod_binding(&self, name: &str, namespace: &str, body: crate::models::V1Binding, dry_run: Option<&str>, field_manager: Option<&str>, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Binding, Error = Error<serde_json::Value>>>;
    fn create_namespaced_pod_eviction(&self, name: &str, namespace: &str, body: crate::models::V1beta1Eviction, dry_run: Option<&str>, field_manager: Option<&str>, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1beta1Eviction, Error = Error<serde_json::Value>>>;
    fn create_namespaced_pod_template(&self, namespace: &str, body: crate::models::V1PodTemplate, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PodTemplate, Error = Error<serde_json::Value>>>;
    fn create_namespaced_replication_controller(&self, namespace: &str, body: crate::models::V1ReplicationController, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ReplicationController, Error = Error<serde_json::Value>>>;
    fn create_namespaced_resource_quota(&self, namespace: &str, body: crate::models::V1ResourceQuota, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ResourceQuota, Error = Error<serde_json::Value>>>;
    fn create_namespaced_secret(&self, namespace: &str, body: crate::models::V1Secret, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Secret, Error = Error<serde_json::Value>>>;
    fn create_namespaced_service(&self, namespace: &str, body: crate::models::V1Service, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Service, Error = Error<serde_json::Value>>>;
    fn create_namespaced_service_account(&self, namespace: &str, body: crate::models::V1ServiceAccount, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ServiceAccount, Error = Error<serde_json::Value>>>;
    fn create_namespaced_service_account_token(&self, name: &str, namespace: &str, body: crate::models::AuthenticationV1TokenRequest, dry_run: Option<&str>, field_manager: Option<&str>, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::AuthenticationV1TokenRequest, Error = Error<serde_json::Value>>>;
    fn create_node(&self, body: crate::models::V1Node, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Node, Error = Error<serde_json::Value>>>;
    fn create_persistent_volume(&self, body: crate::models::V1PersistentVolume, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PersistentVolume, Error = Error<serde_json::Value>>>;
    fn delete_collection_namespaced_config_map(&self, namespace: &str, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>>;
    fn delete_collection_namespaced_endpoints(&self, namespace: &str, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>>;
    fn delete_collection_namespaced_event(&self, namespace: &str, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>>;
    fn delete_collection_namespaced_limit_range(&self, namespace: &str, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>>;
    fn delete_collection_namespaced_persistent_volume_claim(&self, namespace: &str, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>>;
    fn delete_collection_namespaced_pod(&self, namespace: &str, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>>;
    fn delete_collection_namespaced_pod_template(&self, namespace: &str, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>>;
    fn delete_collection_namespaced_replication_controller(&self, namespace: &str, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>>;
    fn delete_collection_namespaced_resource_quota(&self, namespace: &str, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>>;
    fn delete_collection_namespaced_secret(&self, namespace: &str, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>>;
    fn delete_collection_namespaced_service_account(&self, namespace: &str, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>>;
    fn delete_collection_node(&self, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>>;
    fn delete_collection_persistent_volume(&self, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>>;
    fn delete_namespace(&self, name: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>>;
    fn delete_namespaced_config_map(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>>;
    fn delete_namespaced_endpoints(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>>;
    fn delete_namespaced_event(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>>;
    fn delete_namespaced_limit_range(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>>;
    fn delete_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1PersistentVolumeClaim, Error = Error<serde_json::Value>>>;
    fn delete_namespaced_pod(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Pod, Error = Error<serde_json::Value>>>;
    fn delete_namespaced_pod_template(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1PodTemplate, Error = Error<serde_json::Value>>>;
    fn delete_namespaced_replication_controller(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>>;
    fn delete_namespaced_resource_quota(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1ResourceQuota, Error = Error<serde_json::Value>>>;
    fn delete_namespaced_secret(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>>;
    fn delete_namespaced_service(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>>;
    fn delete_namespaced_service_account(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1ServiceAccount, Error = Error<serde_json::Value>>>;
    fn delete_node(&self, name: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>>;
    fn delete_persistent_volume(&self, name: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1PersistentVolume, Error = Error<serde_json::Value>>>;
    fn get_api_resources(&self, ) -> Box<dyn Future<Item = crate::models::V1ApiResourceList, Error = Error<serde_json::Value>>>;
    fn list_component_status(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ComponentStatusList, Error = Error<serde_json::Value>>>;
    fn list_config_map_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ConfigMapList, Error = Error<serde_json::Value>>>;
    fn list_endpoints_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1EndpointsList, Error = Error<serde_json::Value>>>;
    fn list_event_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::CoreV1EventList, Error = Error<serde_json::Value>>>;
    fn list_limit_range_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1LimitRangeList, Error = Error<serde_json::Value>>>;
    fn list_namespace(&self, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1NamespaceList, Error = Error<serde_json::Value>>>;
    fn list_namespaced_config_map(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ConfigMapList, Error = Error<serde_json::Value>>>;
    fn list_namespaced_endpoints(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1EndpointsList, Error = Error<serde_json::Value>>>;
    fn list_namespaced_event(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::CoreV1EventList, Error = Error<serde_json::Value>>>;
    fn list_namespaced_limit_range(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1LimitRangeList, Error = Error<serde_json::Value>>>;
    fn list_namespaced_persistent_volume_claim(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PersistentVolumeClaimList, Error = Error<serde_json::Value>>>;
    fn list_namespaced_pod(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PodList, Error = Error<serde_json::Value>>>;
    fn list_namespaced_pod_template(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PodTemplateList, Error = Error<serde_json::Value>>>;
    fn list_namespaced_replication_controller(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ReplicationControllerList, Error = Error<serde_json::Value>>>;
    fn list_namespaced_resource_quota(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ResourceQuotaList, Error = Error<serde_json::Value>>>;
    fn list_namespaced_secret(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1SecretList, Error = Error<serde_json::Value>>>;
    fn list_namespaced_service(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ServiceList, Error = Error<serde_json::Value>>>;
    fn list_namespaced_service_account(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ServiceAccountList, Error = Error<serde_json::Value>>>;
    fn list_node(&self, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1NodeList, Error = Error<serde_json::Value>>>;
    fn list_persistent_volume(&self, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PersistentVolumeList, Error = Error<serde_json::Value>>>;
    fn list_persistent_volume_claim_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PersistentVolumeClaimList, Error = Error<serde_json::Value>>>;
    fn list_pod_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PodList, Error = Error<serde_json::Value>>>;
    fn list_pod_template_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PodTemplateList, Error = Error<serde_json::Value>>>;
    fn list_replication_controller_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ReplicationControllerList, Error = Error<serde_json::Value>>>;
    fn list_resource_quota_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ResourceQuotaList, Error = Error<serde_json::Value>>>;
    fn list_secret_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1SecretList, Error = Error<serde_json::Value>>>;
    fn list_service_account_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ServiceAccountList, Error = Error<serde_json::Value>>>;
    fn list_service_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ServiceList, Error = Error<serde_json::Value>>>;
    fn patch_namespace(&self, name: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1Namespace, Error = Error<serde_json::Value>>>;
    fn patch_namespace_status(&self, name: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1Namespace, Error = Error<serde_json::Value>>>;
    fn patch_namespaced_config_map(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ConfigMap, Error = Error<serde_json::Value>>>;
    fn patch_namespaced_endpoints(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1Endpoints, Error = Error<serde_json::Value>>>;
    fn patch_namespaced_event(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::CoreV1Event, Error = Error<serde_json::Value>>>;
    fn patch_namespaced_limit_range(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1LimitRange, Error = Error<serde_json::Value>>>;
    fn patch_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PersistentVolumeClaim, Error = Error<serde_json::Value>>>;
    fn patch_namespaced_persistent_volume_claim_status(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PersistentVolumeClaim, Error = Error<serde_json::Value>>>;
    fn patch_namespaced_pod(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1Pod, Error = Error<serde_json::Value>>>;
    fn patch_namespaced_pod_ephemeralcontainers(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1EphemeralContainers, Error = Error<serde_json::Value>>>;
    fn patch_namespaced_pod_status(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1Pod, Error = Error<serde_json::Value>>>;
    fn patch_namespaced_pod_template(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PodTemplate, Error = Error<serde_json::Value>>>;
    fn patch_namespaced_replication_controller(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ReplicationController, Error = Error<serde_json::Value>>>;
    fn patch_namespaced_replication_controller_scale(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1Scale, Error = Error<serde_json::Value>>>;
    fn patch_namespaced_replication_controller_status(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ReplicationController, Error = Error<serde_json::Value>>>;
    fn patch_namespaced_resource_quota(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ResourceQuota, Error = Error<serde_json::Value>>>;
    fn patch_namespaced_resource_quota_status(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ResourceQuota, Error = Error<serde_json::Value>>>;
    fn patch_namespaced_secret(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1Secret, Error = Error<serde_json::Value>>>;
    fn patch_namespaced_service(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1Service, Error = Error<serde_json::Value>>>;
    fn patch_namespaced_service_account(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ServiceAccount, Error = Error<serde_json::Value>>>;
    fn patch_namespaced_service_status(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1Service, Error = Error<serde_json::Value>>>;
    fn patch_node(&self, name: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1Node, Error = Error<serde_json::Value>>>;
    fn patch_node_status(&self, name: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1Node, Error = Error<serde_json::Value>>>;
    fn patch_persistent_volume(&self, name: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PersistentVolume, Error = Error<serde_json::Value>>>;
    fn patch_persistent_volume_status(&self, name: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PersistentVolume, Error = Error<serde_json::Value>>>;
    fn read_component_status(&self, name: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ComponentStatus, Error = Error<serde_json::Value>>>;
    fn read_namespace(&self, name: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Namespace, Error = Error<serde_json::Value>>>;
    fn read_namespace_status(&self, name: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Namespace, Error = Error<serde_json::Value>>>;
    fn read_namespaced_config_map(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ConfigMap, Error = Error<serde_json::Value>>>;
    fn read_namespaced_endpoints(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Endpoints, Error = Error<serde_json::Value>>>;
    fn read_namespaced_event(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::CoreV1Event, Error = Error<serde_json::Value>>>;
    fn read_namespaced_limit_range(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1LimitRange, Error = Error<serde_json::Value>>>;
    fn read_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PersistentVolumeClaim, Error = Error<serde_json::Value>>>;
    fn read_namespaced_persistent_volume_claim_status(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PersistentVolumeClaim, Error = Error<serde_json::Value>>>;
    fn read_namespaced_pod(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Pod, Error = Error<serde_json::Value>>>;
    fn read_namespaced_pod_ephemeralcontainers(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1EphemeralContainers, Error = Error<serde_json::Value>>>;
    fn read_namespaced_pod_log(&self, name: &str, namespace: &str, container: Option<&str>, follow: Option<bool>, insecure_skip_tls_verify_backend: Option<bool>, limit_bytes: Option<i32>, pretty: Option<&str>, previous: Option<bool>, since_seconds: Option<i32>, tail_lines: Option<i32>, timestamps: Option<bool>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>>;
    fn read_namespaced_pod_status(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Pod, Error = Error<serde_json::Value>>>;
    fn read_namespaced_pod_template(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PodTemplate, Error = Error<serde_json::Value>>>;
    fn read_namespaced_replication_controller(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ReplicationController, Error = Error<serde_json::Value>>>;
    fn read_namespaced_replication_controller_scale(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Scale, Error = Error<serde_json::Value>>>;
    fn read_namespaced_replication_controller_status(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ReplicationController, Error = Error<serde_json::Value>>>;
    fn read_namespaced_resource_quota(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ResourceQuota, Error = Error<serde_json::Value>>>;
    fn read_namespaced_resource_quota_status(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ResourceQuota, Error = Error<serde_json::Value>>>;
    fn read_namespaced_secret(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Secret, Error = Error<serde_json::Value>>>;
    fn read_namespaced_service(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Service, Error = Error<serde_json::Value>>>;
    fn read_namespaced_service_account(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ServiceAccount, Error = Error<serde_json::Value>>>;
    fn read_namespaced_service_status(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Service, Error = Error<serde_json::Value>>>;
    fn read_node(&self, name: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Node, Error = Error<serde_json::Value>>>;
    fn read_node_status(&self, name: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Node, Error = Error<serde_json::Value>>>;
    fn read_persistent_volume(&self, name: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PersistentVolume, Error = Error<serde_json::Value>>>;
    fn read_persistent_volume_status(&self, name: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PersistentVolume, Error = Error<serde_json::Value>>>;
    fn replace_namespace(&self, name: &str, body: crate::models::V1Namespace, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Namespace, Error = Error<serde_json::Value>>>;
    fn replace_namespace_finalize(&self, name: &str, body: crate::models::V1Namespace, dry_run: Option<&str>, field_manager: Option<&str>, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Namespace, Error = Error<serde_json::Value>>>;
    fn replace_namespace_status(&self, name: &str, body: crate::models::V1Namespace, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Namespace, Error = Error<serde_json::Value>>>;
    fn replace_namespaced_config_map(&self, name: &str, namespace: &str, body: crate::models::V1ConfigMap, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ConfigMap, Error = Error<serde_json::Value>>>;
    fn replace_namespaced_endpoints(&self, name: &str, namespace: &str, body: crate::models::V1Endpoints, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Endpoints, Error = Error<serde_json::Value>>>;
    fn replace_namespaced_event(&self, name: &str, namespace: &str, body: crate::models::CoreV1Event, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::CoreV1Event, Error = Error<serde_json::Value>>>;
    fn replace_namespaced_limit_range(&self, name: &str, namespace: &str, body: crate::models::V1LimitRange, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1LimitRange, Error = Error<serde_json::Value>>>;
    fn replace_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, body: crate::models::V1PersistentVolumeClaim, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PersistentVolumeClaim, Error = Error<serde_json::Value>>>;
    fn replace_namespaced_persistent_volume_claim_status(&self, name: &str, namespace: &str, body: crate::models::V1PersistentVolumeClaim, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PersistentVolumeClaim, Error = Error<serde_json::Value>>>;
    fn replace_namespaced_pod(&self, name: &str, namespace: &str, body: crate::models::V1Pod, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Pod, Error = Error<serde_json::Value>>>;
    fn replace_namespaced_pod_ephemeralcontainers(&self, name: &str, namespace: &str, body: crate::models::V1EphemeralContainers, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1EphemeralContainers, Error = Error<serde_json::Value>>>;
    fn replace_namespaced_pod_status(&self, name: &str, namespace: &str, body: crate::models::V1Pod, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Pod, Error = Error<serde_json::Value>>>;
    fn replace_namespaced_pod_template(&self, name: &str, namespace: &str, body: crate::models::V1PodTemplate, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PodTemplate, Error = Error<serde_json::Value>>>;
    fn replace_namespaced_replication_controller(&self, name: &str, namespace: &str, body: crate::models::V1ReplicationController, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ReplicationController, Error = Error<serde_json::Value>>>;
    fn replace_namespaced_replication_controller_scale(&self, name: &str, namespace: &str, body: crate::models::V1Scale, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Scale, Error = Error<serde_json::Value>>>;
    fn replace_namespaced_replication_controller_status(&self, name: &str, namespace: &str, body: crate::models::V1ReplicationController, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ReplicationController, Error = Error<serde_json::Value>>>;
    fn replace_namespaced_resource_quota(&self, name: &str, namespace: &str, body: crate::models::V1ResourceQuota, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ResourceQuota, Error = Error<serde_json::Value>>>;
    fn replace_namespaced_resource_quota_status(&self, name: &str, namespace: &str, body: crate::models::V1ResourceQuota, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ResourceQuota, Error = Error<serde_json::Value>>>;
    fn replace_namespaced_secret(&self, name: &str, namespace: &str, body: crate::models::V1Secret, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Secret, Error = Error<serde_json::Value>>>;
    fn replace_namespaced_service(&self, name: &str, namespace: &str, body: crate::models::V1Service, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Service, Error = Error<serde_json::Value>>>;
    fn replace_namespaced_service_account(&self, name: &str, namespace: &str, body: crate::models::V1ServiceAccount, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ServiceAccount, Error = Error<serde_json::Value>>>;
    fn replace_namespaced_service_status(&self, name: &str, namespace: &str, body: crate::models::V1Service, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Service, Error = Error<serde_json::Value>>>;
    fn replace_node(&self, name: &str, body: crate::models::V1Node, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Node, Error = Error<serde_json::Value>>>;
    fn replace_node_status(&self, name: &str, body: crate::models::V1Node, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Node, Error = Error<serde_json::Value>>>;
    fn replace_persistent_volume(&self, name: &str, body: crate::models::V1PersistentVolume, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PersistentVolume, Error = Error<serde_json::Value>>>;
    fn replace_persistent_volume_status(&self, name: &str, body: crate::models::V1PersistentVolume, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PersistentVolume, Error = Error<serde_json::Value>>>;
}

impl<C: hyper::client::Connect>CoreV1Api for CoreV1ApiClient<C> {
    fn connect_delete_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/pods/{name}/proxy".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_delete_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path2 {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_path_param("path".to_string(), path.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_delete_namespaced_service_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/services/{name}/proxy".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_delete_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path2 {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_path_param("path".to_string(), path.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_delete_node_proxy(&self, name: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/nodes/{name}/proxy".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_delete_node_proxy_with_path(&self, name: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/nodes/{name}/proxy/{path}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path2 {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("path".to_string(), path.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_get_namespaced_pod_attach(&self, name: &str, namespace: &str, container: Option<&str>, stderr: Option<bool>, stdin: Option<bool>, stdout: Option<bool>, tty: Option<bool>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/pods/{name}/attach".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = container {
            req = req.with_query_param("container".to_string(), s.to_string());
        }
        if let Some(ref s) = stderr {
            req = req.with_query_param("stderr".to_string(), s.to_string());
        }
        if let Some(ref s) = stdin {
            req = req.with_query_param("stdin".to_string(), s.to_string());
        }
        if let Some(ref s) = stdout {
            req = req.with_query_param("stdout".to_string(), s.to_string());
        }
        if let Some(ref s) = tty {
            req = req.with_query_param("tty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_get_namespaced_pod_exec(&self, name: &str, namespace: &str, command: Option<&str>, container: Option<&str>, stderr: Option<bool>, stdin: Option<bool>, stdout: Option<bool>, tty: Option<bool>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/pods/{name}/exec".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = command {
            req = req.with_query_param("command".to_string(), s.to_string());
        }
        if let Some(ref s) = container {
            req = req.with_query_param("container".to_string(), s.to_string());
        }
        if let Some(ref s) = stderr {
            req = req.with_query_param("stderr".to_string(), s.to_string());
        }
        if let Some(ref s) = stdin {
            req = req.with_query_param("stdin".to_string(), s.to_string());
        }
        if let Some(ref s) = stdout {
            req = req.with_query_param("stdout".to_string(), s.to_string());
        }
        if let Some(ref s) = tty {
            req = req.with_query_param("tty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_get_namespaced_pod_portforward(&self, name: &str, namespace: &str, ports: Option<i32>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/pods/{name}/portforward".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = ports {
            req = req.with_query_param("ports".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_get_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/pods/{name}/proxy".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_get_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path2 {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_path_param("path".to_string(), path.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_get_namespaced_service_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/services/{name}/proxy".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_get_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path2 {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_path_param("path".to_string(), path.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_get_node_proxy(&self, name: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/nodes/{name}/proxy".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_get_node_proxy_with_path(&self, name: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/nodes/{name}/proxy/{path}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path2 {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("path".to_string(), path.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_head_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Head, "/api/v1/namespaces/{namespace}/pods/{name}/proxy".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_head_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Head, "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path2 {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_path_param("path".to_string(), path.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_head_namespaced_service_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Head, "/api/v1/namespaces/{namespace}/services/{name}/proxy".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_head_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Head, "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path2 {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_path_param("path".to_string(), path.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_head_node_proxy(&self, name: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Head, "/api/v1/nodes/{name}/proxy".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_head_node_proxy_with_path(&self, name: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Head, "/api/v1/nodes/{name}/proxy/{path}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path2 {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("path".to_string(), path.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_options_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Options, "/api/v1/namespaces/{namespace}/pods/{name}/proxy".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_options_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Options, "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path2 {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_path_param("path".to_string(), path.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_options_namespaced_service_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Options, "/api/v1/namespaces/{namespace}/services/{name}/proxy".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_options_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Options, "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path2 {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_path_param("path".to_string(), path.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_options_node_proxy(&self, name: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Options, "/api/v1/nodes/{name}/proxy".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_options_node_proxy_with_path(&self, name: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Options, "/api/v1/nodes/{name}/proxy/{path}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path2 {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("path".to_string(), path.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_patch_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{namespace}/pods/{name}/proxy".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_patch_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path2 {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_path_param("path".to_string(), path.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_patch_namespaced_service_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{namespace}/services/{name}/proxy".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_patch_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path2 {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_path_param("path".to_string(), path.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_patch_node_proxy(&self, name: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/nodes/{name}/proxy".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_patch_node_proxy_with_path(&self, name: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/nodes/{name}/proxy/{path}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path2 {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("path".to_string(), path.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_post_namespaced_pod_attach(&self, name: &str, namespace: &str, container: Option<&str>, stderr: Option<bool>, stdin: Option<bool>, stdout: Option<bool>, tty: Option<bool>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces/{namespace}/pods/{name}/attach".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = container {
            req = req.with_query_param("container".to_string(), s.to_string());
        }
        if let Some(ref s) = stderr {
            req = req.with_query_param("stderr".to_string(), s.to_string());
        }
        if let Some(ref s) = stdin {
            req = req.with_query_param("stdin".to_string(), s.to_string());
        }
        if let Some(ref s) = stdout {
            req = req.with_query_param("stdout".to_string(), s.to_string());
        }
        if let Some(ref s) = tty {
            req = req.with_query_param("tty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_post_namespaced_pod_exec(&self, name: &str, namespace: &str, command: Option<&str>, container: Option<&str>, stderr: Option<bool>, stdin: Option<bool>, stdout: Option<bool>, tty: Option<bool>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces/{namespace}/pods/{name}/exec".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = command {
            req = req.with_query_param("command".to_string(), s.to_string());
        }
        if let Some(ref s) = container {
            req = req.with_query_param("container".to_string(), s.to_string());
        }
        if let Some(ref s) = stderr {
            req = req.with_query_param("stderr".to_string(), s.to_string());
        }
        if let Some(ref s) = stdin {
            req = req.with_query_param("stdin".to_string(), s.to_string());
        }
        if let Some(ref s) = stdout {
            req = req.with_query_param("stdout".to_string(), s.to_string());
        }
        if let Some(ref s) = tty {
            req = req.with_query_param("tty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_post_namespaced_pod_portforward(&self, name: &str, namespace: &str, ports: Option<i32>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces/{namespace}/pods/{name}/portforward".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = ports {
            req = req.with_query_param("ports".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_post_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces/{namespace}/pods/{name}/proxy".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_post_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path2 {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_path_param("path".to_string(), path.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_post_namespaced_service_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces/{namespace}/services/{name}/proxy".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_post_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path2 {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_path_param("path".to_string(), path.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_post_node_proxy(&self, name: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/nodes/{name}/proxy".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_post_node_proxy_with_path(&self, name: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/nodes/{name}/proxy/{path}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path2 {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("path".to_string(), path.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_put_namespaced_pod_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{namespace}/pods/{name}/proxy".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_put_namespaced_pod_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path2 {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_path_param("path".to_string(), path.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_put_namespaced_service_proxy(&self, name: &str, namespace: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{namespace}/services/{name}/proxy".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_put_namespaced_service_proxy_with_path(&self, name: &str, namespace: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path2 {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_path_param("path".to_string(), path.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_put_node_proxy(&self, name: &str, path: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/nodes/{name}/proxy".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());

        req.execute(self.configuration.borrow())
    }

    fn connect_put_node_proxy_with_path(&self, name: &str, path: &str, path2: Option<&str>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/nodes/{name}/proxy/{path}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = path2 {
            req = req.with_query_param("path".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("path".to_string(), path.to_string());

        req.execute(self.configuration.borrow())
    }

    fn create_namespace(&self, body: crate::models::V1Namespace, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Namespace, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn create_namespaced_binding(&self, namespace: &str, body: crate::models::V1Binding, dry_run: Option<&str>, field_manager: Option<&str>, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Binding, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces/{namespace}/bindings".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn create_namespaced_config_map(&self, namespace: &str, body: crate::models::V1ConfigMap, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ConfigMap, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces/{namespace}/configmaps".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn create_namespaced_endpoints(&self, namespace: &str, body: crate::models::V1Endpoints, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Endpoints, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces/{namespace}/endpoints".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn create_namespaced_event(&self, namespace: &str, body: crate::models::CoreV1Event, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::CoreV1Event, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces/{namespace}/events".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn create_namespaced_limit_range(&self, namespace: &str, body: crate::models::V1LimitRange, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1LimitRange, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces/{namespace}/limitranges".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn create_namespaced_persistent_volume_claim(&self, namespace: &str, body: crate::models::V1PersistentVolumeClaim, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PersistentVolumeClaim, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces/{namespace}/persistentvolumeclaims".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn create_namespaced_pod(&self, namespace: &str, body: crate::models::V1Pod, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Pod, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces/{namespace}/pods".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn create_namespaced_pod_binding(&self, name: &str, namespace: &str, body: crate::models::V1Binding, dry_run: Option<&str>, field_manager: Option<&str>, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Binding, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces/{namespace}/pods/{name}/binding".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn create_namespaced_pod_eviction(&self, name: &str, namespace: &str, body: crate::models::V1beta1Eviction, dry_run: Option<&str>, field_manager: Option<&str>, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1beta1Eviction, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces/{namespace}/pods/{name}/eviction".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn create_namespaced_pod_template(&self, namespace: &str, body: crate::models::V1PodTemplate, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PodTemplate, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces/{namespace}/podtemplates".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn create_namespaced_replication_controller(&self, namespace: &str, body: crate::models::V1ReplicationController, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ReplicationController, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces/{namespace}/replicationcontrollers".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn create_namespaced_resource_quota(&self, namespace: &str, body: crate::models::V1ResourceQuota, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ResourceQuota, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces/{namespace}/resourcequotas".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn create_namespaced_secret(&self, namespace: &str, body: crate::models::V1Secret, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Secret, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces/{namespace}/secrets".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn create_namespaced_service(&self, namespace: &str, body: crate::models::V1Service, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Service, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces/{namespace}/services".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn create_namespaced_service_account(&self, namespace: &str, body: crate::models::V1ServiceAccount, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ServiceAccount, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces/{namespace}/serviceaccounts".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn create_namespaced_service_account_token(&self, name: &str, namespace: &str, body: crate::models::AuthenticationV1TokenRequest, dry_run: Option<&str>, field_manager: Option<&str>, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::AuthenticationV1TokenRequest, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/namespaces/{namespace}/serviceaccounts/{name}/token".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn create_node(&self, body: crate::models::V1Node, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Node, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/nodes".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn create_persistent_volume(&self, body: crate::models::V1PersistentVolume, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PersistentVolume, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Post, "/api/v1/persistentvolumes".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_collection_namespaced_config_map(&self, namespace: &str, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/configmaps".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_collection_namespaced_endpoints(&self, namespace: &str, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/endpoints".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_collection_namespaced_event(&self, namespace: &str, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/events".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_collection_namespaced_limit_range(&self, namespace: &str, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/limitranges".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_collection_namespaced_persistent_volume_claim(&self, namespace: &str, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/persistentvolumeclaims".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_collection_namespaced_pod(&self, namespace: &str, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/pods".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_collection_namespaced_pod_template(&self, namespace: &str, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/podtemplates".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_collection_namespaced_replication_controller(&self, namespace: &str, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/replicationcontrollers".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_collection_namespaced_resource_quota(&self, namespace: &str, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/resourcequotas".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_collection_namespaced_secret(&self, namespace: &str, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/secrets".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_collection_namespaced_service_account(&self, namespace: &str, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/serviceaccounts".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_collection_node(&self, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/nodes".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_collection_persistent_volume(&self, pretty: Option<&str>, _continue: Option<&str>, dry_run: Option<&str>, field_selector: Option<&str>, grace_period_seconds: Option<i32>, label_selector: Option<&str>, limit: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/persistentvolumes".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_namespace(&self, name: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_namespaced_config_map(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/configmaps/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_namespaced_endpoints(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/endpoints/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_namespaced_event(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/events/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_namespaced_limit_range(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/limitranges/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1PersistentVolumeClaim, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_namespaced_pod(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Pod, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/pods/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_namespaced_pod_template(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1PodTemplate, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/podtemplates/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_namespaced_replication_controller(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_namespaced_resource_quota(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1ResourceQuota, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/resourcequotas/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_namespaced_secret(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/secrets/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_namespaced_service(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/services/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_namespaced_service_account(&self, name: &str, namespace: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1ServiceAccount, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/namespaces/{namespace}/serviceaccounts/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_node(&self, name: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1Status, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/nodes/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn delete_persistent_volume(&self, name: &str, pretty: Option<&str>, dry_run: Option<&str>, grace_period_seconds: Option<i32>, orphan_dependents: Option<bool>, propagation_policy: Option<&str>, body: Option<crate::models::V1DeleteOptions>) -> Box<dyn Future<Item = crate::models::V1PersistentVolume, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Delete, "/api/v1/persistentvolumes/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = grace_period_seconds {
            req = req.with_query_param("gracePeriodSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = orphan_dependents {
            req = req.with_query_param("orphanDependents".to_string(), s.to_string());
        }
        if let Some(ref s) = propagation_policy {
            req = req.with_query_param("propagationPolicy".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn get_api_resources(&self, ) -> Box<dyn Future<Item = crate::models::V1ApiResourceList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;

        req.execute(self.configuration.borrow())
    }

    fn list_component_status(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ComponentStatusList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/componentstatuses".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }

        req.execute(self.configuration.borrow())
    }

    fn list_config_map_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ConfigMapList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/configmaps".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }

        req.execute(self.configuration.borrow())
    }

    fn list_endpoints_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1EndpointsList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/endpoints".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }

        req.execute(self.configuration.borrow())
    }

    fn list_event_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::CoreV1EventList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/events".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }

        req.execute(self.configuration.borrow())
    }

    fn list_limit_range_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1LimitRangeList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/limitranges".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }

        req.execute(self.configuration.borrow())
    }

    fn list_namespace(&self, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1NamespaceList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }

        req.execute(self.configuration.borrow())
    }

    fn list_namespaced_config_map(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ConfigMapList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/configmaps".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn list_namespaced_endpoints(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1EndpointsList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/endpoints".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn list_namespaced_event(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::CoreV1EventList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/events".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn list_namespaced_limit_range(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1LimitRangeList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/limitranges".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn list_namespaced_persistent_volume_claim(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PersistentVolumeClaimList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/persistentvolumeclaims".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn list_namespaced_pod(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PodList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/pods".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn list_namespaced_pod_template(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PodTemplateList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/podtemplates".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn list_namespaced_replication_controller(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ReplicationControllerList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/replicationcontrollers".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn list_namespaced_resource_quota(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ResourceQuotaList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/resourcequotas".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn list_namespaced_secret(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1SecretList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/secrets".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn list_namespaced_service(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ServiceList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/services".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn list_namespaced_service_account(&self, namespace: &str, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ServiceAccountList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/serviceaccounts".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn list_node(&self, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1NodeList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/nodes".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }

        req.execute(self.configuration.borrow())
    }

    fn list_persistent_volume(&self, pretty: Option<&str>, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PersistentVolumeList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/persistentvolumes".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }

        req.execute(self.configuration.borrow())
    }

    fn list_persistent_volume_claim_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PersistentVolumeClaimList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/persistentvolumeclaims".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }

        req.execute(self.configuration.borrow())
    }

    fn list_pod_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PodList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/pods".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }

        req.execute(self.configuration.borrow())
    }

    fn list_pod_template_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PodTemplateList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/podtemplates".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }

        req.execute(self.configuration.borrow())
    }

    fn list_replication_controller_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ReplicationControllerList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/replicationcontrollers".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }

        req.execute(self.configuration.borrow())
    }

    fn list_resource_quota_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ResourceQuotaList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/resourcequotas".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }

        req.execute(self.configuration.borrow())
    }

    fn list_secret_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1SecretList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/secrets".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }

        req.execute(self.configuration.borrow())
    }

    fn list_service_account_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ServiceAccountList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/serviceaccounts".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }

        req.execute(self.configuration.borrow())
    }

    fn list_service_for_all_namespaces(&self, allow_watch_bookmarks: Option<bool>, _continue: Option<&str>, field_selector: Option<&str>, label_selector: Option<&str>, limit: Option<i32>, pretty: Option<&str>, resource_version: Option<&str>, resource_version_match: Option<&str>, timeout_seconds: Option<i32>, watch: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ServiceList, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/services".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = allow_watch_bookmarks {
            req = req.with_query_param("allowWatchBookmarks".to_string(), s.to_string());
        }
        if let Some(ref s) = _continue {
            req = req.with_query_param("continue".to_string(), s.to_string());
        }
        if let Some(ref s) = field_selector {
            req = req.with_query_param("fieldSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = label_selector {
            req = req.with_query_param("labelSelector".to_string(), s.to_string());
        }
        if let Some(ref s) = limit {
            req = req.with_query_param("limit".to_string(), s.to_string());
        }
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version {
            req = req.with_query_param("resourceVersion".to_string(), s.to_string());
        }
        if let Some(ref s) = resource_version_match {
            req = req.with_query_param("resourceVersionMatch".to_string(), s.to_string());
        }
        if let Some(ref s) = timeout_seconds {
            req = req.with_query_param("timeoutSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = watch {
            req = req.with_query_param("watch".to_string(), s.to_string());
        }

        req.execute(self.configuration.borrow())
    }

    fn patch_namespace(&self, name: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1Namespace, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_namespace_status(&self, name: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1Namespace, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_namespaced_config_map(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ConfigMap, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{namespace}/configmaps/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_namespaced_endpoints(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1Endpoints, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{namespace}/endpoints/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_namespaced_event(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::CoreV1Event, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{namespace}/events/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_namespaced_limit_range(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1LimitRange, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{namespace}/limitranges/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PersistentVolumeClaim, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_namespaced_persistent_volume_claim_status(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PersistentVolumeClaim, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_namespaced_pod(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1Pod, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{namespace}/pods/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_namespaced_pod_ephemeralcontainers(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1EphemeralContainers, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_namespaced_pod_status(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1Pod, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{namespace}/pods/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_namespaced_pod_template(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PodTemplate, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{namespace}/podtemplates/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_namespaced_replication_controller(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ReplicationController, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_namespaced_replication_controller_scale(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1Scale, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_namespaced_replication_controller_status(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ReplicationController, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_namespaced_resource_quota(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ResourceQuota, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{namespace}/resourcequotas/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_namespaced_resource_quota_status(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ResourceQuota, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{namespace}/resourcequotas/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_namespaced_secret(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1Secret, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{namespace}/secrets/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_namespaced_service(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1Service, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{namespace}/services/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_namespaced_service_account(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1ServiceAccount, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{namespace}/serviceaccounts/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_namespaced_service_status(&self, name: &str, namespace: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1Service, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/namespaces/{namespace}/services/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_node(&self, name: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1Node, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/nodes/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_node_status(&self, name: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1Node, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/nodes/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_persistent_volume(&self, name: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PersistentVolume, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/persistentvolumes/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn patch_persistent_volume_status(&self, name: &str, body: serde_json::Value, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>, force: Option<bool>) -> Box<dyn Future<Item = crate::models::V1PersistentVolume, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Patch, "/api/v1/persistentvolumes/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = force {
            req = req.with_query_param("force".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn read_component_status(&self, name: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ComponentStatus, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/componentstatuses/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_namespace(&self, name: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Namespace, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_namespace_status(&self, name: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Namespace, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_namespaced_config_map(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ConfigMap, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/configmaps/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_namespaced_endpoints(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Endpoints, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/endpoints/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_namespaced_event(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::CoreV1Event, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/events/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_namespaced_limit_range(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1LimitRange, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/limitranges/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PersistentVolumeClaim, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_namespaced_persistent_volume_claim_status(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PersistentVolumeClaim, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_namespaced_pod(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Pod, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/pods/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_namespaced_pod_ephemeralcontainers(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1EphemeralContainers, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_namespaced_pod_log(&self, name: &str, namespace: &str, container: Option<&str>, follow: Option<bool>, insecure_skip_tls_verify_backend: Option<bool>, limit_bytes: Option<i32>, pretty: Option<&str>, previous: Option<bool>, since_seconds: Option<i32>, tail_lines: Option<i32>, timestamps: Option<bool>) -> Box<dyn Future<Item = String, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/pods/{name}/log".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = container {
            req = req.with_query_param("container".to_string(), s.to_string());
        }
        if let Some(ref s) = follow {
            req = req.with_query_param("follow".to_string(), s.to_string());
        }
        if let Some(ref s) = insecure_skip_tls_verify_backend {
            req = req.with_query_param("insecureSkipTLSVerifyBackend".to_string(), s.to_string());
        }
        if let Some(ref s) = limit_bytes {
            req = req.with_query_param("limitBytes".to_string(), s.to_string());
        }
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = previous {
            req = req.with_query_param("previous".to_string(), s.to_string());
        }
        if let Some(ref s) = since_seconds {
            req = req.with_query_param("sinceSeconds".to_string(), s.to_string());
        }
        if let Some(ref s) = tail_lines {
            req = req.with_query_param("tailLines".to_string(), s.to_string());
        }
        if let Some(ref s) = timestamps {
            req = req.with_query_param("timestamps".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_namespaced_pod_status(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Pod, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/pods/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_namespaced_pod_template(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PodTemplate, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/podtemplates/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_namespaced_replication_controller(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ReplicationController, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_namespaced_replication_controller_scale(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Scale, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_namespaced_replication_controller_status(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ReplicationController, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_namespaced_resource_quota(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ResourceQuota, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/resourcequotas/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_namespaced_resource_quota_status(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ResourceQuota, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/resourcequotas/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_namespaced_secret(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Secret, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/secrets/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_namespaced_service(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Service, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/services/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_namespaced_service_account(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ServiceAccount, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/serviceaccounts/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_namespaced_service_status(&self, name: &str, namespace: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Service, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/namespaces/{namespace}/services/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_node(&self, name: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Node, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/nodes/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_node_status(&self, name: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Node, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/nodes/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_persistent_volume(&self, name: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PersistentVolume, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/persistentvolumes/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());

        req.execute(self.configuration.borrow())
    }

    fn read_persistent_volume_status(&self, name: &str, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PersistentVolume, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Get, "/api/v1/persistentvolumes/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());

        req.execute(self.configuration.borrow())
    }

    fn replace_namespace(&self, name: &str, body: crate::models::V1Namespace, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Namespace, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_namespace_finalize(&self, name: &str, body: crate::models::V1Namespace, dry_run: Option<&str>, field_manager: Option<&str>, pretty: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Namespace, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{name}/finalize".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_namespace_status(&self, name: &str, body: crate::models::V1Namespace, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Namespace, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_namespaced_config_map(&self, name: &str, namespace: &str, body: crate::models::V1ConfigMap, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ConfigMap, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{namespace}/configmaps/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_namespaced_endpoints(&self, name: &str, namespace: &str, body: crate::models::V1Endpoints, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Endpoints, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{namespace}/endpoints/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_namespaced_event(&self, name: &str, namespace: &str, body: crate::models::CoreV1Event, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::CoreV1Event, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{namespace}/events/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_namespaced_limit_range(&self, name: &str, namespace: &str, body: crate::models::V1LimitRange, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1LimitRange, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{namespace}/limitranges/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_namespaced_persistent_volume_claim(&self, name: &str, namespace: &str, body: crate::models::V1PersistentVolumeClaim, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PersistentVolumeClaim, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_namespaced_persistent_volume_claim_status(&self, name: &str, namespace: &str, body: crate::models::V1PersistentVolumeClaim, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PersistentVolumeClaim, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_namespaced_pod(&self, name: &str, namespace: &str, body: crate::models::V1Pod, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Pod, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{namespace}/pods/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_namespaced_pod_ephemeralcontainers(&self, name: &str, namespace: &str, body: crate::models::V1EphemeralContainers, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1EphemeralContainers, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{namespace}/pods/{name}/ephemeralcontainers".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_namespaced_pod_status(&self, name: &str, namespace: &str, body: crate::models::V1Pod, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Pod, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{namespace}/pods/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_namespaced_pod_template(&self, name: &str, namespace: &str, body: crate::models::V1PodTemplate, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PodTemplate, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{namespace}/podtemplates/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_namespaced_replication_controller(&self, name: &str, namespace: &str, body: crate::models::V1ReplicationController, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ReplicationController, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_namespaced_replication_controller_scale(&self, name: &str, namespace: &str, body: crate::models::V1Scale, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Scale, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_namespaced_replication_controller_status(&self, name: &str, namespace: &str, body: crate::models::V1ReplicationController, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ReplicationController, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_namespaced_resource_quota(&self, name: &str, namespace: &str, body: crate::models::V1ResourceQuota, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ResourceQuota, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{namespace}/resourcequotas/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_namespaced_resource_quota_status(&self, name: &str, namespace: &str, body: crate::models::V1ResourceQuota, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ResourceQuota, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{namespace}/resourcequotas/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_namespaced_secret(&self, name: &str, namespace: &str, body: crate::models::V1Secret, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Secret, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{namespace}/secrets/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_namespaced_service(&self, name: &str, namespace: &str, body: crate::models::V1Service, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Service, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{namespace}/services/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_namespaced_service_account(&self, name: &str, namespace: &str, body: crate::models::V1ServiceAccount, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1ServiceAccount, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{namespace}/serviceaccounts/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_namespaced_service_status(&self, name: &str, namespace: &str, body: crate::models::V1Service, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Service, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/namespaces/{namespace}/services/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_path_param("namespace".to_string(), namespace.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_node(&self, name: &str, body: crate::models::V1Node, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Node, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/nodes/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_node_status(&self, name: &str, body: crate::models::V1Node, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1Node, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/nodes/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_persistent_volume(&self, name: &str, body: crate::models::V1PersistentVolume, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PersistentVolume, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/persistentvolumes/{name}".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

    fn replace_persistent_volume_status(&self, name: &str, body: crate::models::V1PersistentVolume, pretty: Option<&str>, dry_run: Option<&str>, field_manager: Option<&str>) -> Box<dyn Future<Item = crate::models::V1PersistentVolume, Error = Error<serde_json::Value>>> {
        let mut req = __internal_request::Request::new(hyper::Method::Put, "/api/v1/persistentvolumes/{name}/status".to_string())
            .with_auth(__internal_request::Auth::ApiKey(__internal_request::ApiKey{
                in_header: true,
                in_query: false,
                param_name: "authorization".to_owned(),
            }))
        ;
        if let Some(ref s) = pretty {
            req = req.with_query_param("pretty".to_string(), s.to_string());
        }
        if let Some(ref s) = dry_run {
            req = req.with_query_param("dryRun".to_string(), s.to_string());
        }
        if let Some(ref s) = field_manager {
            req = req.with_query_param("fieldManager".to_string(), s.to_string());
        }
        req = req.with_path_param("name".to_string(), name.to_string());
        req = req.with_body_param(body);

        req.execute(self.configuration.borrow())
    }

}
